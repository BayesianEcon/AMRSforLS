# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Procrustes Trasnformation
#'
#' It applies Procrustes transformation of a set of n points laying in a d-dimensional space w.r.t. a reference set.
#'
#' @param X is an n x d matrix of reference points
#' @param Y is an n x d matrix of points to transform
#' @return is an n x d matrix of rotated points
#' @export
procrustes_cpp <- function(X, Y) {
    .Call(`_AMRSforLS_procrustes_cpp`, X, Y)
}

#' ARMS Individual
#'
#' The function runs an MCMC algorithm to estimate Latent Space Models using Adaptive Multiple Random Scan.
#' The latent coordinates get probabilistically updated individually.
#'
#' @param y N x N adjacency matrix
#' @param beta   scalar, initial value for the intercept
#' @param beta_a scalar, prior mean for the intercept
#' @param beta_b scalar, prior standard deviation for the intercept
#' @param z_i, N x K matrix, initial value for the latent coordinates
#' @param zeta_a scalar, prior mean of the latent coordinates, usually set to 0
#' @param zeta_b scalar, prior standard deviation of the latent coordinates, usually set to 0
#' @param lam_ad_z N vector, lambda parameters, see Andrieu and Thoms 2008, A tutorial on adaptive MCMC
#' @param mu_mat_z N x K matrix, mu parameters, see Andrieu and Thoms 2008
#' @param Sigma_ad_z List of N K x K matrices,  see Andrieu and Thoms 2008
#' @param N scalar, number of nodes
#' @param K scalar, number of latent dimensions
#' @param prop_sigma_beta scalar, proposal standard deviation for the intercept beta
#' @param acc_target_z scalar, target acceptance rate for the latent coordinates, default 0.234
#' @param scan_every integer, how many iteration before the update of selection probabilities
#' @param Iterations integer, MCMC number of iterations
#' @param k_shift    scalar, shift of the decision rule sigmoid function
#' @param eq_option  binary, if 1 selection probabilities with equal default value
#' @param eq_prob    scalar, between 0 and 1, if eq_option = 1, this is the default value
#' @param ad_option  binary, if ad_option 0 we use the adaptive proposal by Andrieu and Thoms 2008 otherwise by Latuszynski, Roberts and Rosenthal 2013
#' @param distr_option binary, if 0 it runs the algorithm for a LS with Bernoulli likelihood, otherwise with Poisson likelihood, default 1
#' @return List of saved quantities  beta_ite intercpet chain,zeta_ite list of latent positions chains, P_ite matrix of selection probabilities chains, Acc_ite matrix of acceptance rates
#' @export
MCMC_ADRS_AD <- function(y, beta, beta_a, beta_b, z_i, zeta_a, zeta_b, lam_ad_z, mu_mat_z, Sigma_ad_z, N, K, prop_sigma_beta, acc_target_z = 0.234, scan_every = 100L, Iterations = 1000, k_shift = 0, eq_option = 0, eq_prob = 0.5, ad_option = 0, distr_option = 1) {
    .Call(`_AMRSforLS_MCMC_ADRS_AD`, y, beta, beta_a, beta_b, z_i, zeta_a, zeta_b, lam_ad_z, mu_mat_z, Sigma_ad_z, N, K, prop_sigma_beta, acc_target_z, scan_every, Iterations, k_shift, eq_option, eq_prob, ad_option, distr_option)
}

#' ARMS Block
#'
#' The function runs an MCMC algorithm to estimate Latent Space Models using Adaptive Multiple Random Scan.
#' The latent coordinates get probabilistically updated in blocks.
#'
#' @param y N x N adjacency matrix
#' @param beta   scalar, initial value for the intercept
#' @param beta_a scalar, prior mean for the intercept
#' @param beta_b scalar, prior standard deviation for the intercept
#' @param z_i, N x K matrix, initial value for the latent coordinates
#' @param zeta_a scalar, prior mean of the latent coordinates, usually set to 0
#' @param zeta_b scalar, prior standard deviation of the latent coordinates, usually set to 0
#' @param lam_ad_z N vector, lambda parameters, see Andrieu and Thoms 2008, A tutorial on adaptive MCMC
#' @param mu_mat_z N x K matrix, mu parameters, see Andrieu and Thoms 2008
#' @param Sigma_ad_z List of N K x K matrices,  see Andrieu and Thoms 2008
#' @param N scalar, number of nodes
#' @param K scalar, number of latent dimensions
#' @param prop_sigma_beta scalar, proposal standard deviation for the intercept beta
#' @param acc_target_z scalar, target acceptance rate for the latent coordinates, default 0.234
#' @param belong N vector, it contains a index of group for each node, e.g. N = 5, c(1,1,1, 2, 2) creates two groups
#' @param scan_every integer, how many iteration before the update of selection probabilities
#' @param Iterations integer, MCMC number of iterations
#' @param k_shift    scalar, shift of the decision rule sigmoid function
#' @param eq_option  binary, if 1 selection probabilities with equal default value
#' @param ad_option  binary, if ad_option 0 we use the adaptive proposal by Andrieu and Thoms 2008 otherwise by Latuszynski, Roberts and Rosenthal 2013
#' @param distr_option binary, if 0 it runs the algorithm for a LS with Bernoulli likelihood, otherwise with Poisson likelihood, default 1
#' @return List of saved quantities  beta_ite intercpet chain,zeta_ite list of latent positions chains, P_ite matrix of selection probabilities chains, Acc_ite matrix of acceptance rates
#' @export
MCMC_ADRS_BLOCK_AD <- function(y, beta, beta_a, beta_b, z_i, zeta_a, zeta_b, lam_ad_z, mu_mat_z, Sigma_ad_z, N, K, prop_sigma_beta, acc_target_z, belong, scan_every = 100L, Iterations = 1000, k_shift = 0.5, ad_option = 0, eq_option = 0, distr_option = 1) {
    .Call(`_AMRSforLS_MCMC_ADRS_BLOCK_AD`, y, beta, beta_a, beta_b, z_i, zeta_a, zeta_b, lam_ad_z, mu_mat_z, Sigma_ad_z, N, K, prop_sigma_beta, acc_target_z, belong, scan_every, Iterations, k_shift, ad_option, eq_option, distr_option)
}

#' Systematic Gibbs
#'
#' The function runs an MCMC algorithm to estimate Latent Space Models using Systematic Random Scan.
#' The latent coordinates get all sequentially updated.
#'
#' @param y N x N adjacency matrix
#' @param beta   scalar, initial value for the intercept
#' @param beta_a scalar, prior mean for the intercept
#' @param beta_b scalar, prior standard deviation for the intercept
#' @param z_i, N x K matrix, initial value for the latent coordinates
#' @param zeta_a scalar, prior mean of the latent coordinates, usually set to 0
#' @param zeta_b scalar, prior standard deviation of the latent coordinates, usually set to 0
#' @param lam_ad_z N vector, lambda parameters, see Andrieu and Thoms 2008, A tutorial on adaptive MCMC
#' @param mu_mat_z N x K matrix, mu parameters, see Andrieu and Thoms 2008
#' @param Sigma_ad_z List of N K x K matrices,  see Andrieu and Thoms 2008
#' @param N scalar, number of nodes
#' @param K scalar, number of latent dimensions
#' @param prop_sigma_beta scalar, proposal standard deviation for the intercept beta
#' @param acc_target_z scalar, target acceptance rate for the latent coordinates, default 0.234
#' @param Iterations integer, MCMC number of iterations
#' @param ad_option  binary, if ad_option 0 we use the adaptive proposal by Andrieu and Thoms 2008 otherwise by Latuszynski, Roberts and Rosenthal 2013
#' @param distr_option binary, if 0 it runs the algorithm for a LS with Bernoulli likelihood, otherwise with Poisson likelihood, default 1
#' @return List of saved quantities  beta_ite intercpet chain,zeta_ite list of latent positions chains, P_ite matrix of selection probabilities chains, Acc_ite matrix of acceptance rates
#' @export
MCMC_AD <- function(y, beta, beta_a, beta_b, z_i, zeta_a, zeta_b, lam_ad_z, mu_mat_z, Sigma_ad_z, N, K, prop_sigma_beta, acc_target_z, Iterations = 1000, ad_option = 0, distr_option = 1) {
    .Call(`_AMRSforLS_MCMC_AD`, y, beta, beta_a, beta_b, z_i, zeta_a, zeta_b, lam_ad_z, mu_mat_z, Sigma_ad_z, N, K, prop_sigma_beta, acc_target_z, Iterations, ad_option, distr_option)
}

